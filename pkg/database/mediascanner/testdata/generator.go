// Zaparoo Core
// Copyright (c) 2025 The Zaparoo Project Contributors.
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This file is part of Zaparoo Core.
//
// Zaparoo Core is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Zaparoo Core is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Zaparoo Core.  If not, see <http://www.gnu.org/licenses/>.

// Package testdata provides test data generation for media scanner testing.
//
// IMPORTANT COPYRIGHT NOTICE:
// All content generated by this package is entirely fictional and created
// for testing purposes only. No real game titles, copyrighted content, or
// intellectual property is used. All names, titles, and metadata are
// programmatically generated using random combinations of generic terms.
package testdata

import (
	"fmt"
	"math/rand"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/uuid"
)

// TestDataGenerator creates fictional game data for testing
type TestDataGenerator struct {
	rng    *rand.Rand
	genres []string
	themes []string
	types  []string
}

// NewTestDataGenerator creates a new test data generator with a fixed seed for reproducible tests
func NewTestDataGenerator(seed int64) *TestDataGenerator {
	return &TestDataGenerator{
		rng: rand.New(rand.NewSource(seed)),
		genres: []string{
			"Action", "Adventure", "Arcade", "Fighting", "Platform",
			"Puzzle", "Racing", "RPG", "Shooting", "Sports",
			"Strategy", "Simulation", "Music", "Educational",
		},
		themes: []string{
			"Space", "Fantasy", "Sci-Fi", "Medieval", "Modern",
			"Retro", "Cyber", "Magic", "Robot", "Ocean",
			"Desert", "Forest", "City", "Underground", "Sky",
		},
		types: []string{
			"Quest", "Battle", "Adventure", "Challenge", "Mission",
			"Journey", "Trial", "Saga", "Chronicle", "Legend",
			"Story", "Voyage", "Expedition", "Campaign", "Arena",
		},
	}
}

// GenerateGameName creates a fictional game name with realistic patterns
func (g *TestDataGenerator) GenerateGameName() string {
	patterns := []func() string{
		// Pattern: Test_[Theme]_[Type]_[Number]
		func() string {
			theme := g.themes[g.rng.Intn(len(g.themes))]
			gameType := g.types[g.rng.Intn(len(g.types))]
			number := g.rng.Intn(999) + 1
			return fmt.Sprintf("Test_%s_%s_%03d", theme, gameType, number)
		},
		// Pattern: Test_[Genre]_[Theme]_[Type]
		func() string {
			genre := g.genres[g.rng.Intn(len(g.genres))]
			theme := g.themes[g.rng.Intn(len(g.themes))]
			gameType := g.types[g.rng.Intn(len(g.types))]
			return fmt.Sprintf("Test_%s_%s_%s", genre, theme, gameType)
		},
		// Pattern: Test_[Theme]_[Number]_[Genre]
		func() string {
			theme := g.themes[g.rng.Intn(len(g.themes))]
			number := g.rng.Intn(99) + 1
			genre := g.genres[g.rng.Intn(len(g.genres))]
			return fmt.Sprintf("Test_%s_%02d_%s", theme, number, genre)
		},
	}

	pattern := patterns[g.rng.Intn(len(patterns))]
	return pattern()
}

// GenerateGameNameWithVariations creates a game name with realistic filename variations
func (g *TestDataGenerator) GenerateGameNameWithVariations() string {
	baseName := g.GenerateGameName()

	// Add common ROM variations
	variations := []string{
		"",                    // No variation
		"_(USA)",             // Region
		"_(Europe)",          // Region
		"_(Japan)",           // Region
		"_(Rev_1)",           // Revision
		"_(Rev_A)",           // Revision
		"_v1.0",              // Version
		"_v2.1",              // Version
		"_Beta",              // Development
		"_Alpha",             // Development
		"_Demo",              // Demo
		"_Special_Edition",   // Edition
		"_Directors_Cut",     // Edition
		"_[h1]",              // Hack
		"_[t+Eng]",           // Translation
		"_[f1]",              // Fixed
		"_[!]",               // Verified good
		"_[T+Eng1.0]",        // Translation with version
	}

	variation := variations[g.rng.Intn(len(variations))]
	return baseName + variation
}

// GenerateMediaPath creates a full file path for a given system
func (g *TestDataGenerator) GenerateMediaPath(systemID string, index int) string {
	name := g.GenerateGameNameWithVariations()

	// System-specific extensions
	extensions := map[string][]string{
		"NES":          {".nes", ".unf", ".unif"},
		"SNES":         {".sfc", ".smc", ".fig"},
		"Genesis":      {".md", ".gen", ".bin", ".smd"},
		"Gameboy":      {".gb", ".sgb"},
		"GameboyColor": {".gbc", ".cgb"},
		"GBA":          {".gba", ".agb"},
		"Nintendo64":   {".n64", ".v64", ".z64"},
		"PSX":          {".bin", ".cue", ".img", ".iso", ".pbp"},
		"PS2":          {".iso", ".bin", ".img"},
		"Dreamcast":    {".cdi", ".gdi", ".chd"},
		"Saturn":       {".cue", ".bin", ".iso"},
		"Atari2600":    {".a26", ".bin"},
		"Atari7800":    {".a78"},
		"MasterSystem": {".sms"},
		"GameGear":     {".gg"},
		"Lynx":         {".lnx"},
		"default":      {".rom", ".bin", ".img"},
	}

	systemExts := extensions[systemID]
	if systemExts == nil {
		systemExts = extensions["default"]
	}

	ext := systemExts[g.rng.Intn(len(systemExts))]
	filename := name + ext

	// Create realistic directory structure
	return filepath.Join("roms", strings.ToLower(systemID), filename)
}

// GenerateSystemPaths creates multiple file paths for a system
func (g *TestDataGenerator) GenerateSystemPaths(systemID string, count int) []string {
	paths := make([]string, count)
	for i := 0; i < count; i++ {
		paths[i] = g.GenerateMediaPath(systemID, i)
	}
	return paths
}

// TestMediaEntry represents a complete test media entry
type TestMediaEntry struct {
	SystemID string
	Path     string
	Name     string
	Slug     string
}

// GenerateMediaEntry creates a complete test media entry
func (g *TestDataGenerator) GenerateMediaEntry(systemID string) TestMediaEntry {
	path := g.GenerateMediaPath(systemID, 0)
	name := g.GenerateGameName()

	// Create slug from name (lowercase, replace spaces/special chars)
	slug := strings.ToLower(name)
	slug = strings.ReplaceAll(slug, " ", "_")
	slug = strings.ReplaceAll(slug, "-", "_")

	return TestMediaEntry{
		SystemID: systemID,
		Path:     path,
		Name:     name,
		Slug:     slug,
	}
}

// GenerateMediaEntries creates multiple test media entries
func (g *TestDataGenerator) GenerateMediaEntries(systemID string, count int) []TestMediaEntry {
	entries := make([]TestMediaEntry, count)
	for i := 0; i < count; i++ {
		entries[i] = g.GenerateMediaEntry(systemID)
	}
	return entries
}

// TestBatch represents a batch of test data for multiple systems
type TestBatch struct {
	Systems []string
	Entries map[string][]TestMediaEntry
	Total   int
}

// GenerateTestBatch creates a batch of test data across multiple systems
func (g *TestDataGenerator) GenerateTestBatch(systems []string, entriesPerSystem int) TestBatch {
	batch := TestBatch{
		Systems: systems,
		Entries: make(map[string][]TestMediaEntry),
		Total:   0,
	}

	for _, systemID := range systems {
		entries := g.GenerateMediaEntries(systemID, entriesPerSystem)
		batch.Entries[systemID] = entries
		batch.Total += len(entries)
	}

	return batch
}

// CreateReproducibleBatch creates a test batch with a UUID seed for unique but reproducible data
func CreateReproducibleBatch(systems []string, entriesPerSystem int) TestBatch {
	// Use a fixed UUID for reproducible tests, but unique enough to avoid conflicts
	testUUID := uuid.MustParse("12345678-1234-5678-9abc-123456789012")
	seed := int64(testUUID.ID())

	generator := NewTestDataGenerator(seed)
	return generator.GenerateTestBatch(systems, entriesPerSystem)
}

// CreateRandomBatch creates a test batch with current time seed for truly random data
func CreateRandomBatch(systems []string, entriesPerSystem int) TestBatch {
	seed := time.Now().UnixNano()
	generator := NewTestDataGenerator(seed)
	return generator.GenerateTestBatch(systems, entriesPerSystem)
}